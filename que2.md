# Вопросы 1, 10-15, 18-23, 26, 36, 45-47

## Вопрос 1
#### Чем отличается класс от структуры в смысле Си? Как выбрать между классом и структурой в C++? 
#### Ответ: 

Класс — это механизм для создания объектов. Классы представляют собой новые типы данных, которые вводятся в код программистом. 
Обычно пользоваться стандартными типами данных (int, double и т.п.) для описания какого-либо явления или объекта не удобно, т.к. сложный объект 
характеризуется множеством полей (хранимых данных). Для этого вводятся новые типы, которые зачастую обладают большим количеством полей
(хранимых внутри себя переменных). В этом смысле класс лежит в основе многих свойств C++. 

Класс объявляется с помощью ключевого слова `class`. Синтаксис объявления класса похож на синтаксис объявления структуры. Здесь показана основная форма:

    class имя_класса. {  
    // закрытие функции и переменные класса.   
    public:  
    // открытые функции и переменные класса.  
    } список_объектов;

В объявлении класса список_объектов не обязателен. Как и в случае со структурой, вы можете объявлять объекты класса позже, по мере необходимости.

Вас, возможно, удивило то, что класс и структура имеют фактически одинаковые свойства. В C++ определение структуры расширили таким образом, что туда, 
как и в определение класса, удалось включить функции-члены, в том числе конструкторы и деструкторы. Единственным отличием между структурой 
и классом является то, что **члены класса, по умолчанию, являются закрытыми (private), а члены структуры — открытыми (public).**
Однако **в рамках языка Си структура могла содержать только данные, функции обработки структуры были отделены от объектов структуры.**

Структура объявляется с помощью ключевого слова `struct`. Здесь показан расширенный синтаксис описания структуры:

    struct имя_типа. {  
    // открытые функции и данные — члены класса.  
    private:  
    // закрытие функция и данные — члены класса.   
    } список_объектов;

Таким образом, в соответствии с формальным синтаксисом C++ как структура, так и класс создают новые типы данных. 

Хотя структуры имеют схожие с классами возможности, **большинство программистов ограничивают использование структур взятыми из С формами и
не применяют их для задания функций-членов.** Для задания объекта, содержащего данные и код, эти программисты обычно указывают ключевое слово
class. Однако все это относится к стилистике и является предметом вашего собственного выбора. 

**`Замечание` (для тех, кому все-таки интерсно, зачем нужны структуры в рамках C++).** Объяснение этому может быть дано в "строгой" и "мягкой" формах.

"Строгий" довод состоит в том, что необходимо поддерживать линию на совместимость с С. Стиль задания структур С совершенно допустим и для
программ C++. Поскольку в С все члены структур по умолчанию открыты, это положение также поддерживается и в C++. Кроме этого, поскольку
класс синтаксически отличается от структуры, определение класса открыто для развития в направлении, которое в конечном итоге может привести к
несовместимости со взятым из С определением структуры. Если эти два пути разойдутся, то направление, связанное с C++, уже не будет избыточным.

"Мягким" доводом в пользу наличия двух сходных конструкций стало отсутствие какого-либо ущерба от расширения определения структуры в C++
таким образом, что в нее стало возможным включение функций-членов.

***

## Вопрос 10
#### Статические и нестатические атрибуты и методы класса: различия и возможности.
#### Ответ: 


***

## Вопрос 11
#### Чем отличается статический метод от статического атрибута класса? 
#### Ответ: 


***

## Вопрос 12
#### Есть ли особенности наследования у классов со статическими членами? 
#### Ответ: 


***

## Вопрос 13
#### Константные и неконстантные параметры метода. Константный метод: назначение, оформление. 
#### Ответ: 


***

## Вопрос 14
#### Могут ли одноимённые методы с одинаковыми параметрами различаться лишь константностью по одному из параметров? 
#### Ответ: 


***

## Вопрос 15
#### Предопределённый указатель this. Назначение, использование и предосторожности.
#### Ответ: 


***

## Вопрос 18
#### Дружественные функции: назначение и отличия от методов класса. Понятие дружественного класса. 
#### Ответ: 

Возможны ситуации, когда для получения доступа к закрытым членам класса вам понадобится функция, не являющаяся членом этого класса. Для достижения этой цели в C++ поддерживаются дружественные функции (friend functions). **Дружественные функции не являются членами класса, но тем не менее имеют доступ к его закрытым элементам**.

Дружественная функция задается так же, как обычная, не являющаяся членом класса, функция. Однако в объявление класса, для которого функция будет дружественной, необходимо включить ее прототип, перед которым ставится ключевое слово `friend`. В пользу существования дружественных функций имеются несколько доводов, связанных с **перегрузкой операторов и созданием специальных функций ввода/вывода, а так же функций, которые имели бы доступ к закрытым членам двух или более разных классов**.

Чтобы понять, как работает дружественная функция, рассмотрим следующую короткую программу:

    #include <iostream>
    using namespace std;
    
    class myclass (
    int n, d;
    public:
    myclass (int i, int j) { n = i; d = j; }
    // объявление дружественной функции для класса myclass
    friend int isfactor (myclass ob) ;
    };

    int isfactor (myclass ob)
    {
    if(!(ob.n % ob.d)) return 1;
    else return 0;
    }
    
В этом примере в объявлении класса myclass объявляются конструктор и дружественная функция isfactor(). Поскольку функция isfactor() дружественна для класса myclass, 
то функция isfactorQ имеет доступ к его закрытой части. Поэтому внутри функции isfactor() можно непосредственно ссылаться на объекты ob.n и ob.d.

Важно понимать, что дружественная функция не является членом класса, для которого она дружественна. Поэтому **невозможно вызвать дружественную функцию, используя имя объекта и оператор доступа к члену класса (точку или стрелку)**. Например, по отношению к предыдущему примеру ЭТА ИНСТРУКЦИЯ НЕПРАВИЛЬНА:

     obi. is factor () ; // неправильно, isf actor () — это не функция-член
     
Хотя дружественная функция "знает" о закрытых элементах класса, для которого она является дружественной, доступ к ним она может получить только через объект этого класса. Таким образом, **в отличие от функции-члена myclass, в котором можно непосредственно упоминать переменные п и d, дружественная функция может иметь доступ к этим переменным только через объект, который объявлен внутри функции или передан ей**.

**Класс friend — это класс, все функций-члены которого являются дружественными функциями класса**, то есть функции-члены которого имеют доступ к закрытым и защищенным членам другого класса.  Дружественный класс имеет доступ ко всем переменным/функциям исходного класса. Объявляется он так же, как и дружественная функция, с помощью ключевого слова `friend`.

Несколько дополнительных замечаний о дружественных классах. Во-первых, **дружественный класс не имеет прямого доступа к указателю `*this` объектов исходного класса**. Во-вторых, **дружественные отношения не являются взаимными** (сл. вопрос). Если вы хотите, чтобы два класса дружили друг с другом, они оба должны объявить друг друга друзьями. Наконец, если класс A является другом B, а B – другом C, это не означает, что A является другом C.

Будьте осторожны при использовании дружественных функций и классов, потому что это позволяет дружественной функции или классу нарушать инкапсуляцию. Если детали реализации класса изменятся, то детали реализации друга также должны будут быть изменены. Следовательно, ограничьте использование дружественных функций и классов до минимума.

***

## Вопрос 19
#### Может ли класс A быть другом класса B, а обратное не справедливо? 
#### Ответ: 

Да. **Дружественные отношения не являются взаимными, если это не указано явным образом.**  

Если A – друг B, то В – не друг А, пока Вы не укажете это явно. Если A – друг B, В – друг С, то А и С не друзья, пока Вы не укажете это явно.

***

## Вопрос 20
#### Дружественные базовому классу функции и их использование из порождённых классов. 
#### Ответ: 

**Дружественные отношения не наследуются**. Поэтому если в базовый класс включается дружественная функция, то эта дружественная функция не является таковой для производных классов. Поскольку дружественная функция принимает ссылку на объект класса или сам объект, чтобы вызвать друга родителя, имея объект класса потомка, **нужно преобразование к типу родителя**.

***

## Вопрос 21
#### Может ли одна функция быть дружественной нескольким классам одновременно? 
#### Ответ: 

Функцию **можно объявить дружественно сразу нескольким классам**. Для этого описание класса надо разбить на две части (в момент задания прототипа дружественной 
функции в первом классе должна быть информация существовании второго класса).

    class truck; // предварительное объявление
    
    class car {
    int passengers;
    int speed;
    public:
    car(int p, int s) { passengers = p; speed = s; }
    friend int sp_greater (car c, truck t) ;
    };
    
    class truck {
    int weight;
    int speed;
    public:
    truck(int w, int s) { weight = w; speed = s; }
    friend int sp_greater (car c, truck t) ;
    };
    
    int sp_greater (car c, truck t) { return с. speed — t. speed; }
    
В этой программе имеется функция `sp_greater()`, которая дружественна для классов `саг` и `truck`. 

Эта программа иллюстрирует один важный элемент синтаксиса C++ — **предварительное объявление** (forward declaration), которое еще называют **ссылкой
вперед** (forward reference). Поскольку функция sp_greater() получает параметры обоих классов саг и truck, то логически невозможно объявить и тот и другой
класс перед включением функции sp_greater() в каждый из них. Поэтому необходим иной способ сообщить компилятору имя класса без его фактического объявления. Этот способ и называется предварительным объявлением. В C++, чтобы информировать компилятор о том, что данный идентификатор является именем класса, перед первым использованием имени класса вставляют следующую строку:

     class имя_класса; 

***

## Вопрос 22
#### Может ли метод одного класса быть другом другого класса?
#### Ответ: 

**Да**. Сделаем метод класса А дружественной функцией для В. О классе B должно быть известно перед заданием класса А.

    class B;
   
    class A
    {
    private:
    int x;
    public:
    A() { x = 1; }
    void print() { cout << x; }
    void f(B b);
    };
    
    class B  
    {  
    private:
    int y;
    public:
    B() { y = 5; }
    friend void A::f(B b);
    };
    
    void A::f(B b) { x = b.y; }

***

## Вопрос 23
#### Перегрузка функций: назначение и правила. Проиллюстрируйте простыми примерами допустимых и недопустимых вариантов перегрузки.
#### Ответ: 

***

## Вопрос 26
#### Может ли одна и та же операция в одном и том же классе быть перегруженной разными способами? 
#### Ответ: 


***

## Вопрос 36
#### Перегрузка new и delete. Различие скалярной и векторной форм.
#### Ответ: 


***

## Вопрос 45
#### Можно ли перегружать конструктор? Почему? 
#### Ответ: 

В программах на C++ **перегрузка конструктора класса вполне обычна**. Имеется три основных причины перегрузки конструктора, которая, как правило, 
выполняется либо для обеспечения гибкости, либо для поддержки массивов, либо для создания конструкторов копий.

Необходимо запомнить одну вещь: **каждому способу объявления объекта класса должна соответствовать своя версия конструктора класса.** Если 
эта задача не решена, то при компиляции программы обнаружится ошибка. Именно поэтому перегрузка конструктора столь обычна для программ C++.

Изучить на более подробных примерах перегрузку конструкторов можно на стр. 144 - <https://disk.yandex.ru/i/KoKMQ5xd3NhoMR> (или в вопросе 47)

***

## Вопрос 46
#### Можно ли перегружать деструктор? Почему? 
#### Ответ: 

Перегрузка означает наличие нескольких функций с одинаковым именем, которые принимают разные аргументы. **Деструктор не принимает аргументов, и поэтому перегрузка 
не имеет смысла.** Кроме того, деструктор вызывается автоматически и при его перегрузке программа не будет понимать, какой именно деструктор следует использовать.

Если вам нужно делать разные вещи при уничтожении объекта в зависимости от определенных обстоятельств, вам просто нужны соответствующие операторы 
`if` в вашем деструкторе для проверки этих обстоятельств.

***

## Вопрос 47
#### Передача параметров в конструктор и перегрузка конструктора. Что можно сказать о перегрузке деструктора? Конструктор по умолчанию. 
#### Ответ: 

