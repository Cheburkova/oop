# Вопросы 1, 10-15, 18-23, 26, 36, 45-47

## Вопрос 1

**Чем отличается класс от структуры в смысле Си? Как выбрать между классом и структурой в C++?**

**Ответ:** 

Класс — это механизм для создания объектов. Классы представляют собой новые типы данных, которые вводятся в код программистом. 
Обычно пользоваться стандартными типами данных (`int`, `double` и т.п.) для описания какого-либо явления или объекта не удобно, т.к. сложный объект 
характеризуется множеством полей (хранимых данных). Для этого вводятся новые типы, которые зачастую обладают большим количеством полей
(хранимых внутри себя переменных). В этом смысле класс лежит в основе многих свойств C++. 

Класс объявляется с помощью ключевого слова `class`. Синтаксис объявления класса похож на синтаксис объявления структуры. Здесь показана основная форма:
```c++ 
    class имя_класса. {  
    // закрытие функции и переменные класса.   
    public:  
    // открытые функции и переменные класса.  
    } список_объектов;
```
В объявлении класса `список_объектов` не обязателен. Как и в случае со структурой, вы можете объявлять объекты класса позже, по мере необходимости.

Вас, возможно, удивило то, что класс и структура имеют фактически одинаковые свойства. В C++ определение структуры расширили таким образом, что туда, 
как и в определение класса, удалось включить функции-члены, в том числе конструкторы и деструкторы. Единственным отличием между структурой 
и классом является то, что **члены класса, по умолчанию, являются закрытыми (private), а члены структуры — открытыми (public).**
Однако **в рамках языка Си структура могла содержать только данные, функции обработки структуры были отделены от объектов структуры.**

Структура объявляется с помощью ключевого слова `struct`. Здесь показан расширенный синтаксис описания структуры:
```c++ 
    struct имя_типа. {  
    // открытые функции и данные — члены класса.  
    private:  
    // закрытие функция и данные — члены класса.   
    } список_объектов;
```
Таким образом, в соответствии с формальным синтаксисом C++ как структура, так и класс создают новые типы данных. 

Хотя структуры имеют схожие с классами возможности, **большинство программистов ограничивают использование структур взятыми из С формами и
не применяют их для задания функций-членов.** Для задания объекта, содержащего данные и код, эти программисты обычно указывают ключевое слово
`class`. Однако все это относится к стилистике и является предметом вашего собственного выбора. 

**ЗАМЕЧАНИЕ. (для тех, кому все-таки интерсно, зачем нужны структуры в рамках C++).** Объяснение этому может быть дано в "строгой" и "мягкой" формах.

"Строгий" довод состоит в том, что необходимо поддерживать линию на совместимость с С. Стиль задания структур С совершенно допустим и для
программ C++. Поскольку в С все члены структур по умолчанию открыты, это положение также поддерживается и в C++. Кроме этого, поскольку
класс синтаксически отличается от структуры, определение класса открыто для развития в направлении, которое в конечном итоге может привести к
несовместимости со взятым из С определением структуры. Если эти два пути разойдутся, то направление, связанное с C++, уже не будет избыточным.

"Мягким" доводом в пользу наличия двух сходных конструкций стало отсутствие какого-либо ущерба от расширения определения структуры в C++
таким образом, что в нее стало возможным включение функций-членов.

***

## Вопрос 10

**Статические и нестатические атрибуты и методы класса: различия и возможности.**

**Ответ:** 

СТАТИСТИЧЕСКИЕ И НЕСТАТИСТИЧЕСКИЕ АТРИБУТЫ КЛАССА.

Переменные — члены класса можно объявлять как статические (`static`). Они размещаются в специально отведенной области памяти статических переменных. Обычные же (нестатические) данные объектов размещаются в стеке или динамической памяти в зависимости от способа формирования объекта.

Статический компонент можно объявлять не во всяком классе; в частности, в локальных классах, безымянных классах и классах, вложенных в них, не может быть статических компонент.

Если вы объявляете переменную статической, то может существовать только одна копия этой переменной — независимо от того, сколько объектов данного класса создается. Каждый объект просто использует (совместно с другими) эту одну переменную. Запомните, **для обычных (нестатистических) переменных-членов при создании каждого объекта создается их новая копия, и доступ к каждой копии возможен только через этот объект. А копия статической переменной — только одна, и все объекты класса используют её совместно**.

Кроме этого, одна и та же статическая переменная будет использоваться всеми классами, производными от класса, в котором эта статическая переменная содержится. 

При объявлении статического атрибута необходимо обеспечить для него глобальное определение вне класса. Это необходимо для того, чтобы под статический атрибут была выделена память, причём только один раз. Это делается путем нового объявления статической переменной, причем используется оператор области видимости для того, чтобы идентифицировать тот класс, к которому принадлежит переменная.

Основной смысл поддержки в C++ статических переменных-членов состоит в том, что благодаря им отпадает необходимость в использовании глобальных переменных. Как можно предположить, если при работе с классами задавать глобальные переменные, то это почти всегда нарушает принцип инкапсуляции, являющийся фундаментальным принципом OOP и C++.

***Пример подсчёта созданных экземпляров, используя статистическую переменную (Петрусевич может это спросить!!)***
```c++ 
     class A { 
         static int counter;
         int my_number;
      public:
         A() { my_number = counter; counter++; }
         
         int get_number() const { return my_number; }
      };

      int A::counter = 0;

      int static_counter_of_instances()
      {
          A a, b, c, d, e;
          A x[10];
          cout << "a number " << a.get_number() << endl;
          cout << "b number " << b.get_number() << endl;
          cout << "c number " << c.get_number() << endl;
          cout << "d number " << d.get_number() << endl;
          cout << "e number " << e.get_number() << endl;
          for (int i = 0; i < 10; i++)
              cout << "x[" << i << "] number " << x[i].get_number() << endl;
          return 0;
        }
```        
Поскольку статическая переменная — член класса существует ещё до создания объекта этого класса, доступ к ней в программе может быть реализован без всякого объекта:
```c++ 
        int main()
        {
            A::counter = 5;
            ...
        }
```        
**Вопрос на засыпку:** Почему при доступе к A::counter из main() в последнем случае мы получим ошибку компиляции?

**Ответ:** Атрибут counter описан в защищённой части класса. Для доступа к такой переменной можно передвинуть её в зону `public`, но лучше сделать публичным статический метод для доступа к ней.

Необходимо понимать, что **статические переменные медленнее, чем нестатические переменные**. Для того, чтобы обратиться к статической переменной, требуется сделать несколько дополнительных действий (другой сегмент памяти и проверка инициализации переменной). Чаще всего, быстрее выделить локальную переменную на стеке, чем делать дополнительные действия по использованию статической переменной.

СТАТИСТИЧЕСКИЕ И НЕСТАТИСТИЧЕСКИЕ МЕТОДЫ КЛАССА.

Помимо переменных-членов статическими можно объявлять и функции-члены, но обычно это не делается. Доступ к объявленной статической функции — члену класса возможен только для других статических членов этого класса. У статической функции-члена нет указателя `this`. Статические функции-члены не могут быть виртуальными. Статические функции-члены не могут объявляться с идентификаторами `const` (постоянный) и `volatile` (переменный). И наконец, статические функции — члены класса могут вызываться любым объектом этого класса, а также через имя класса и оператор расширения области видимости без всякой связи с каким бы то ни было объектом этого класса.

Однако статические методы могут оказаться удобными для предварительной инициализации закрытых статических атрибутов до создания экземпляров или просто независимо от доступа к ним.

В некоторых языках программирования есть возможность инициализировать статические поля через статический конструктор. В С++ такой возможности нет.

***

## Вопрос 11

**Чем отличается статический метод от статического атрибута класса?** 

**Ответ:** 

Статистические атрибуты – это поля, т.е. статистические переменные класса, а методы – это функции. (?, очень странный вопрос)

***

## Вопрос 12

**Есть ли особенности наследования у классов со статическими членами?** 

**Ответ:** 

Очевидно из предыдущих вопросов! Имеется только одна копия статической переменной — члена класса, и все объекты класса используют ее совместно. Кроме этого, **одна и та же статическая переменная будет использоваться всеми классами, производными от класса, в котором эта статическая переменная содержится.**

***

## Вопрос 13

**Константные и неконстантные параметры метода. Константный метод: назначение, оформление.**

**Ответ:**

Сперва сделаем краткий обзор на константные и неконстантные параметры функции. 

Параметры могут быть константными - значения таких параметров не могут меняться. Константному параметру можно передать в качестве аргумента как константу, так и переменную:
```c++ 
    #include <iostream>

    void square(const int, const int);

    int main()
    {
        const int a = 4;
        int b = 5;
        square(a, b);   // 20
        return 0;
    }
    void square(const int a, const int b)
    {
        //a = a * a;     так нельзя сделать
        //b = b * b;     так нельзя сделать
        std::cout << "In square: a * b = " << a * b << std::endl;
```        
От этой ситуации следует отличать передачу констант в качестве аргументов для неконстантных параметров:
```c++ 
    #include <iostream>

    void square(int, int);

    int main()
    {
        const int a = 4;
        const int b = 5;
        square(a, b);   // 400
        return 0;
    }
    void square(int a, int b)
    {
        a = a * a;
        b = b * b;
        std::cout << "In square: a * b = " << a * b << std::endl;
    }
```    
Несмотря на то, что при вызове функции ей передаются константы, но так как сами параметры не являются константными, то функция может изменять их значения. Обзор закончен, переходим к важным вещам!1!!!

Функции — члены класса могут объявляться постоянными (с идентификатором `const`). **Если функция объявлена постоянной, она не может изменить вызывающий ее объект**. Кроме этого, постоянный объект не может вызвать непостоянную функцию-член. Тем не менее, постоянная функция-член может вызываться как постоянными, так и непостоянными объектами.

Обратите внимание, что ключевое слово `const` указывают следом за списком параметров функции, а не перед именем функции:
```c++ 
    class X {
        int some_var;
    public:
        int fl() const; // постоянная функция-член
    };
```
Для примера рассмотрим следующую программу.
```c++ 
    #include <iostream>
    using namespace std;
    class Demo {
            int i;
        public:
            int geti () const {
                return i; // здесь все правильно
            }
            void seti (int x) const {
                i = x; // Ошибка!!!
            }
    };
    
    int main() {
        Demo ob;
        ob.seti(1900) ;
        cout << ob.geti();
        return 0;
    }
```
Данная программа не будет компилироваться, поскольку функция-член `seti()` объявлена постоянной, что означает невозможность изменения вызывающего ее объекта. Таким образом, попытка изменения функцией переменной i ведет к ошибке. С другой стороны, поскольку функция `geti()` не меняет переменной i, она совершенно правильна.

Возможна ситуация, когда вам понадобится, чтобы функция-член, оставаясь постоянной, тем не менее была способна изменить один или несколько членов класса. Это достигается заданием модифицируемых членов класса (ключевое слово `mutable`). **Модифицируемый член класса можно изменить с помощью постоянной функции-члена.**
```c++ 
    #include <iostream>
    using namespace std;
    
    class Demo {
            mutable int i;
            int j ;
        public:
        
        int geti() const {
        return i; // здесь все правильно
        }
        
        void seti(int x) const {
            i = x; // теперь все правильно
        }
        
        void setj (int x) const {
            j = x; // здесь прежняя ошибка
        }
    };
    
    int main ()
    {
        Demo ob;
        ob.seti(1900) ;
        cout << ob.geti () ;
        return 0;
    }
```
Здесь переменная i задана модифицируемой, поэтому ее может изменить функция-член `seti()`. Тем не менее, поскольку переменная j по-прежнему остается не модифицируемой, постоянная функция-член `setj()` не может изменить ее значение.

***

## Вопрос 14

**Могут ли одноимённые методы с одинаковыми параметрами различаться лишь константностью по одному из параметров?**

**Ответ:**

Объявления параметров, которые отличаются только наличием или отсутствием `const` и / или `volatile` эквивалентны. Программа не будет компилироваться, поскольку воспринимает их за один и тот же метод.

А вот перегрузить функцию таким образом, чтобы получить константную и неконстантную версии одной и той же функции, возможно. Это работает, потому что квалификатор `const` считается частью сигнатуры функции, поэтому две функции, которые отличаются только своей константностью, считаются разными.

***

## Вопрос 15

**Предопределённый указатель this. Назначение, использование и предосторожности.**

**Ответ:** 

C++ содержит специальный указатель `this`. Это указатель, который **автоматически передается любой функции-члену при ее вызове и указывает на объект, генерирующий вызов**. Явно объявить, инициализировать либо изменить указатель `this`, возможности нет. Поскольку указатель неизменяем, назначения указателю this запрещены.

Важно понимать, что указатель **`this` передается только функциям-членам**. Дружественным функциям указатель `this` не передается.

Указатель объекта `this` не является частью самого объекта. Он не отражается в результате `sizeof` оператора для объекта. Если для объекта вызывается нестатическая функция-член, **компилятор передает адрес объекта функции в качестве скрытого аргумента**. Например, вызов следующей функции
```c++ 
    myDate.setMonth( 3 );
```    
можно интерпретировать следующим образом:
```c++ 
    setMonth( &myDate, 3 );
```
Использовать указатель this можно no-разному. Он **особенно полезен при перегрузке операторов**. 

Выражение `*this` обычно **используется для возврата текущего объекта из функции-члена**:
```c++ 
    return *this;
```    
Указатель `this` также **используется для защиты от самосохраняющей ссылки**:
```c++ 
    if (&Object != this) {
    // do not execute in cases of self-reference
```
A так выглядел бы код, если бы мы всегда прописывали все через указатель `this` (так дейтсвительно можно писать, но это не имеет смысла):
```c++ 
        #include <iostream>
        #include <cstring>
        using namespace std;
        
        class inventory {
            char item[20] ;
            double cost;
            int on_hand;
        public:
            inventory (char *i, double c, int o)
            {
                strcpy (this->item, i) ; // доступ к члену
                this->cost = с; // через
                this->on_hand = о; // указатель this
            }
            void show {};
        };
        
        void inventory::show()
        {
            cout « this->item; // использование this для доступа к членам
            cout « ": $" « this->cost;
            cout « " On hand: " « this->on_hand « "\n";
        }
```
***

## Вопрос 18

**Дружественные функции: назначение и отличия от методов класса. Понятие дружественного класса.** 

**Ответ:**

Возможны ситуации, когда для получения доступа к закрытым членам класса вам понадобится функция, не являющаяся членом этого класса. Для достижения этой цели в C++ поддерживаются дружественные функции (`friend functions`). **Дружественные функции не являются членами класса, но тем не менее имеют доступ к его закрытым элементам**.

Дружественная функция задается так же, как обычная, не являющаяся членом класса, функция. Однако в объявление класса, для которого функция будет дружественной, необходимо включить ее прототип, перед которым ставится ключевое слово `friend`. В пользу существования дружественных функций имеются несколько доводов, связанных с **перегрузкой операторов и созданием специальных функций ввода/вывода, а так же функций, которые имели бы доступ к закрытым членам двух или более разных классов**.

Чтобы понять, как работает дружественная функция, рассмотрим следующую короткую программу:
```c++ 
    #include <iostream>
    using namespace std;
    
    class myclass {
            int n, d;
        public:
            myclass (int i, int j) { n = i; d = j; }
            // объявление дружественной функции для класса myclass
            friend int isfactor (myclass ob) ;
    };

    int isfactor (myclass ob)
    {
        if(!(ob.n % ob.d)) return 1;
        else return 0;
    }
```    
В этом примере в объявлении класса `myclass` объявляются конструктор и дружественная функция `isfactor()`. Поскольку функция `isfactor()` дружественна для класса `myclass`, то функция `isfactor()` имеет доступ к его закрытой части. Поэтому внутри функции `isfactor()` можно непосредственно ссылаться на объекты ob.n и ob.d.

Важно понимать, что дружественная функция не является членом класса, для которого она дружественна. Поэтому **невозможно вызвать дружественную функцию, используя имя объекта и оператор доступа к члену класса (точку или стрелку)**. Например, по отношению к предыдущему примеру ЭТА ИНСТРУКЦИЯ НЕПРАВИЛЬНА:
```c++ 
     obi. is factor () ; // неправильно, isf actor () — это не функция-член
 ```    
Хотя дружественная функция "знает" о закрытых элементах класса, для которого она является дружественной, доступ к ним она может получить только через объект этого класса. Таким образом, **в отличие от функции-члена myclass, в котором можно непосредственно упоминать переменные п и d, дружественная функция может иметь доступ к этим переменным только через объект, который объявлен внутри функции или передан ей**.

**Класс friend — это класс, все функций-члены которого являются дружественными функциями класса**, то есть функции-члены которого имеют доступ к закрытым и защищенным членам другого класса.  Дружественный класс имеет доступ ко всем переменным/функциям исходного класса. Объявляется он так же, как и дружественная функция, с помощью ключевого слова `friend`.

Несколько дополнительных замечаний о дружественных классах. Во-первых, **дружественный класс не имеет прямого доступа к указателю `*this` объектов исходного класса**. Во-вторых, **дружественные отношения не являются взаимными** (сл. вопрос). Если вы хотите, чтобы два класса дружили друг с другом, они оба должны объявить друг друга друзьями. Наконец, если класс A является другом B, а B – другом C, это не означает, что A является другом C.

Будьте осторожны при использовании дружественных функций и классов, потому что это позволяет дружественной функции или классу нарушать инкапсуляцию. Если детали реализации класса изменятся, то детали реализации друга также должны будут быть изменены. Следовательно, ограничьте использование дружественных функций и классов до минимума.

***

## Вопрос 19

**Может ли класс A быть другом класса B, а обратное не справедливо?** 

**Ответ: **

Да. **Дружественные отношения не являются взаимными, если это не указано явным образом.**  

Если A – друг B, то В – не друг А, пока Вы не укажете это явно. Если A – друг B, В – друг С, то А и С не друзья, пока Вы не укажете это явно.

***

## Вопрос 20

**Дружественные базовому классу функции и их использование из порождённых классов.** 

**Ответ:** 

**Дружественные отношения не наследуются**. Поэтому если в базовый класс включается дружественная функция, то эта дружественная функция не является таковой для производных классов. Поскольку дружественная функция принимает ссылку на объект класса или сам объект, чтобы вызвать друга родителя, имея объект класса потомка, **нужно преобразование к типу родителя**.

***

## Вопрос 21

**Может ли одна функция быть дружественной нескольким классам одновременно?**

**Ответ:** 

Функцию **можно объявить дружественно сразу нескольким классам**. Для этого описание класса надо разбить на две части (в момент задания прототипа дружественной 
функции в первом классе должна быть информация существовании второго класса).
```c++ 
    class truck; // предварительное объявление
    
    class car {
            int passengers;
            int speed;
        public:
            car(int p, int s) { passengers = p; speed = s; }
            friend int sp_greater (car c, truck t) ;
    };
    
    class truck {
            int weight;
            int speed;
        public:
            truck(int w, int s) { weight = w; speed = s; }
            friend int sp_greater (car c, truck t) ;
    };
    
    int sp_greater (car c, truck t) { return с. speed — t. speed; }
```    
В этой программе имеется функция `sp_greater()`, которая дружественна для классов `саг` и `truck`. 

Эта программа иллюстрирует один важный элемент синтаксиса C++ — **предварительное объявление** (`forward declaration`), которое еще называют **ссылкой
вперед** (`forward reference`). Поскольку функция `sp_greater()` получает параметры обоих классов `саг` и `truck`, то логически невозможно объявить и тот и другой
класс перед включением функции `sp_greater()` в каждый из них. Поэтому необходим иной способ сообщить компилятору имя класса без его фактического объявления. Этот способ и называется предварительным объявлением. В C++, чтобы информировать компилятор о том, что данный идентификатор является именем класса, перед первым использованием имени класса вставляют следующую строку:
```c++ 
     class имя_класса; 
```
***

## Вопрос 22

**Может ли метод одного класса быть другом другого класса?**

**Ответ:**

**Да**. Сделаем метод класса А дружественной функцией для В. О классе B должно быть известно перед заданием класса А.
```c++ 
    class B;
   
    class A {
        private:
            int x;
        public:
            A() { x = 1; }
            void print() { cout << x; }
            void f(B b);
    };
    
    class B {  
        private:
            int y;
        public:
            B() { y = 5; }
            friend void A::f(B b);
    };
    
    void A::f(B b) { x = b.y; }
```
***

## Вопрос 23

**Перегрузка функций: назначение и правила. Проиллюстрируйте простыми примерами допустимых и недопустимых вариантов перегрузки.**

**Ответ:** 

**Перегрузка функций** – это возможность использовать одно имя функции для множества различных действий. Это означает, что **можно создать общий интерфейс для группы близких по смыслу действий**. Т.е. перегруженные функции позволяют упростить программы, допуская обращение к одному имени для выполнения близких по смыслу действий. В C++ две или более функции могут **иметь одно и то же имя, отличаясь либо типом, либо числом своих аргументов, либо и тем и другим**.

Перегрузить функцию очень легко: просто объявите и определите все требуемые варианты. Компилятор автоматически выберет правильный вариант вызова на основании числа и/или типа используемых в функции аргументов.

**ПРИМЕРЫ**

1. Для языка С, в котором полиморфизм поддерживается недостаточно, нахождение абсолютной величины числа требует трех различных функций: `abs()`, `labs()` и `fabs()`. Эти функции подсчитывают и возвращают абсолютную величину целых, длинных целых и чисел с плавающей точкой соответственно. В C++ каждая из этих функций может быть названа `abs()`. Так выглядит реализация этого:
```c++ 
        #include <iostream>
        using namespace std;

        // Перегрузка abs() тремя способами
        int abs(int n);
        long abs(long n);
        double abs(double n);

        int main() {
            cout << "Абсолютная величина -10:" << abs(-10) << "\n/n";
            cout << "Абсолютная величина -10L:" << abs (-10L) << "\n/n";
            cout << "Абсолютная величина -10.01:" << abs (-10. 01) << "\n/n";
            return 0;
        }

        // abs() для целых
        int abs (int n) {
            cout << "В целом abs()\n";
            return n < 0 ? -n: n;
        }

        // abs() для длинных целых
        long abs (long n) {
            cout << "В длинном целом abs()\n";
            return n < 0 ? -n: n;
        }

        // abs() для вещественных двойной точности
        double abs (double n} {
            cout << "В вещественном abs() двойной точности \n";
            return n < 0 ? -n: n;
        }
```
2. Здесь могли быть кодики с перегрузкой функций, отличающихся типами и/или числом принимаемых параметров, но их не будет, потому что вы умняшки и сами все умеете 

3. ПРИМЕР НЕДОПУСТИМОЙ ПЕРЕГРУЗКИ ФУНКЦИИ. Важно понимать, что **тип возвращаемого значения сам по себе еще не является достаточным отличием для перегрузки функции**. Если две функции отличаются только типом возвращаемых данных, компилятор не всегда сможет выбрать нужную.
                
```c++ 
        // Это все неправильно и не будет компилироваться
        int fl{int a);
        double fl{int а);
        ...         
        f1 (10); // какую функцию выбрать компилятору???         
```
***

## Вопрос 26

**Может ли одна и та же операция в одном и том же классе быть перегруженной разными способами?** 

**Ответ:** 

Один и тот же оператор **можно перегрузить несколько раз**. Для унарных операторов может быть всего два варианта — с квалификатором `const` и без него (для функций-членов), или варианты с параметром типа константная ссылка или обычная ссылка (для свободных функций). Для бинарных операторов и оператора () количество перегрузок не ограничено.

***

## Вопрос 36

**Перегрузка new и delete. Различие скалярной и векторной форм.**

**Ответ:**


***

## Вопрос 45

**Можно ли перегружать конструктор? Почему?** 

**Ответ:**

В программах на C++ **перегрузка конструктора класса вполне обычна**. Имеется три основных причины перегрузки конструктора, которая, как правило, 
выполняется либо для обеспечения гибкости, либо для поддержки массивов, либо для создания конструкторов копий.

Необходимо запомнить одну вещь: **каждому способу объявления объекта класса должна соответствовать своя версия конструктора класса.** Если 
эта задача не решена, то при компиляции программы обнаружится ошибка. Именно поэтому перегрузка конструктора столь обычна для программ C++.

Изучить на более подробных примерах перегрузку конструкторов можно на стр. 144 - <https://disk.yandex.ru/i/KoKMQ5xd3NhoMR> (или в вопросе 47)

***

## Вопрос 46

**Можно ли перегружать деструктор? Почему?** 

**Ответ:** 

Перегрузка означает наличие нескольких функций с одинаковым именем, которые принимают разные аргументы. **Деструктор не принимает аргументов, и поэтому перегрузка 
не имеет смысла.** Кроме того, деструктор вызывается автоматически и при его перегрузке программа не будет понимать, какой именно деструктор следует использовать.

Если вам нужно делать разные вещи при уничтожении объекта в зависимости от определенных обстоятельств, вам просто нужны соответствующие операторы 
`if` в вашем деструкторе для проверки этих обстоятельств.

***

## Вопрос 47

**Передача параметров в конструктор и перегрузка конструктора. Что можно сказать о перегрузке деструктора? Конструктор по умолчанию.** 

**Ответ:** 

