# Вопросы 1, 10-15, 18-23, 26, 36, 45-47

## Вопрос 1

**Чем отличается класс от структуры в смысле Си? Как выбрать между классом и структурой в C++?**

**Ответ:** 

Класс — это механизм для создания объектов. Классы представляют собой новые типы данных, которые вводятся в код программистом. 
Обычно пользоваться стандартными типами данных (`int`, `double` и т.п.) для описания какого-либо явления или объекта не удобно, т.к. сложный объект 
характеризуется множеством полей (хранимых данных). Для этого вводятся новые типы, которые зачастую обладают большим количеством полей
(хранимых внутри себя переменных). В этом смысле класс лежит в основе многих свойств C++. 

Класс объявляется с помощью ключевого слова `class`. Синтаксис объявления класса похож на синтаксис объявления структуры. Здесь показана основная форма:
```c++ 
class имя_класса. {  
// закрытие функции и переменные класса.   
public:  
// открытые функции и переменные класса.  
} список_объектов;
```
В объявлении класса `список_объектов` не обязателен. Как и в случае со структурой, вы можете объявлять объекты класса позже, по мере необходимости.

Вас, возможно, удивило то, что класс и структура имеют фактически одинаковые свойства. В C++ определение структуры расширили таким образом, что туда, 
как и в определение класса, удалось включить функции-члены, в том числе конструкторы и деструкторы. Единственным отличием между структурой 
и классом является то, что **члены класса, по умолчанию, являются закрытыми (private), а члены структуры — открытыми (public).**
Однако **в рамках языка Си структура могла содержать только данные, функции обработки структуры были отделены от объектов структуры.**

Структура объявляется с помощью ключевого слова `struct`. Здесь показан расширенный синтаксис описания структуры:
```c++ 
struct имя_типа. {  
// открытые функции и данные — члены класса.  
private:  
// закрытие функция и данные — члены класса.   
} список_объектов;
```
Таким образом, в соответствии с формальным синтаксисом C++ как структура, так и класс создают новые типы данных. 

Хотя структуры имеют схожие с классами возможности, **большинство программистов ограничивают использование структур взятыми из С формами и
не применяют их для задания функций-членов.** Для задания объекта, содержащего данные и код, эти программисты обычно указывают ключевое слово
`class`. Однако все это относится к стилистике и является предметом вашего собственного выбора. 

**ЗАМЕЧАНИЕ. (для тех, кому все-таки интерсно, зачем нужны структуры в рамках C++).** Объяснение этому может быть дано в "строгой" и "мягкой" формах.

"Строгий" довод состоит в том, что необходимо поддерживать линию на совместимость с С. Стиль задания структур С совершенно допустим и для
программ C++. Поскольку в С все члены структур по умолчанию открыты, это положение также поддерживается и в C++. Кроме этого, поскольку
класс синтаксически отличается от структуры, определение класса открыто для развития в направлении, которое в конечном итоге может привести к
несовместимости со взятым из С определением структуры. Если эти два пути разойдутся, то направление, связанное с C++, уже не будет избыточным.

"Мягким" доводом в пользу наличия двух сходных конструкций стало отсутствие какого-либо ущерба от расширения определения структуры в C++
таким образом, что в нее стало возможным включение функций-членов.

***

## Вопрос 10

**Статические и нестатические атрибуты и методы класса: различия и возможности.**

**Ответ:** 

СТАТИСТИЧЕСКИЕ И НЕСТАТИСТИЧЕСКИЕ АТРИБУТЫ КЛАССА.

Переменные — члены класса можно объявлять как статические (`static`). Они размещаются в специально отведенной области памяти статических переменных. Обычные же (нестатические) данные объектов размещаются в стеке или динамической памяти в зависимости от способа формирования объекта.

Статический компонент можно объявлять не во всяком классе; в частности, в локальных классах, безымянных классах и классах, вложенных в них, не может быть статических компонент.

Если вы объявляете переменную статической, то может существовать только одна копия этой переменной — независимо от того, сколько объектов данного класса создается. Каждый объект просто использует (совместно с другими) эту одну переменную. Запомните, **для обычных (нестатистических) переменных-членов при создании каждого объекта создается их новая копия, и доступ к каждой копии возможен только через этот объект. А копия статической переменной — только одна, и все объекты класса используют её совместно**.

Кроме этого, одна и та же статическая переменная будет использоваться всеми классами, производными от класса, в котором эта статическая переменная содержится. 

При объявлении статического атрибута необходимо обеспечить для него глобальное определение вне класса. Это необходимо для того, чтобы под статический атрибут была выделена память, причём только один раз. Это делается путем нового объявления статической переменной, причем используется оператор области видимости для того, чтобы идентифицировать тот класс, к которому принадлежит переменная.

Основной смысл поддержки в C++ статических переменных-членов состоит в том, что благодаря им отпадает необходимость в использовании глобальных переменных. Как можно предположить, если при работе с классами задавать глобальные переменные, то это почти всегда нарушает принцип инкапсуляции, являющийся фундаментальным принципом OOP и C++.

***Пример подсчёта созданных экземпляров, используя статистическую переменную (Петрусевич может это спросить!!)***
```c++ 
class A { 
     static int counter;
     int my_number;
public:
     A() { my_number = counter; counter++; }    
     int get_number() const { return my_number; }
};

int A::counter = 0;

int static_counter_of_instances()
{
     A a, b, c, d, e;
     A x[10];
     cout << "a number " << a.get_number() << endl;
     cout << "b number " << b.get_number() << endl;
     cout << "c number " << c.get_number() << endl;
     cout << "d number " << d.get_number() << endl;
     cout << "e number " << e.get_number() << endl;
     for (int i = 0; i < 10; i++)
          cout << "x[" << i << "] number " << x[i].get_number() << endl;
     return 0;
}
```        
Поскольку статическая переменная — член класса существует ещё до создания объекта этого класса, доступ к ней в программе может быть реализован без всякого объекта:
```c++ 
int main() {
     A::counter = 5;
     ...
}
```        
**Вопрос на засыпку:** Почему при доступе к `A::counter` из `main()` в последнем случае мы получим ошибку компиляции?

**Ответ:** Атрибут `counter` описан в защищённой части класса. Для доступа к такой переменной можно передвинуть её в зону `public`, но лучше сделать публичным статический метод для доступа к ней.

Необходимо понимать, что **статические переменные медленнее, чем нестатические переменные**. Для того, чтобы обратиться к статической переменной, требуется сделать несколько дополнительных действий (другой сегмент памяти и проверка инициализации переменной). Чаще всего, быстрее выделить локальную переменную на стеке, чем делать дополнительные действия по использованию статической переменной.

СТАТИСТИЧЕСКИЕ И НЕСТАТИСТИЧЕСКИЕ МЕТОДЫ КЛАССА.

Помимо переменных-членов статическими можно объявлять и функции-члены, но обычно это не делается. Доступ к объявленной статической функции — члену класса возможен только для других статических членов этого класса. У статической функции-члена нет указателя `this`. Статические функции-члены не могут быть виртуальными. Статические функции-члены не могут объявляться с идентификаторами `const` (постоянный) и `volatile` (переменный). И наконец, статические функции — члены класса могут вызываться любым объектом этого класса, а также через имя класса и оператор расширения области видимости без всякой связи с каким бы то ни было объектом этого класса.

Однако статические методы могут оказаться удобными для предварительной инициализации закрытых статических атрибутов до создания экземпляров или просто независимо от доступа к ним.

В некоторых языках программирования есть возможность инициализировать статические поля через статический конструктор. В С++ такой возможности нет.

***

## Вопрос 11

**Чем отличается статический метод от статического атрибута класса?** 

**Ответ:** 

Статистические атрибуты – это поля, т.е. статистические переменные класса, а методы – это функции. (?, очень странный вопрос)

***

## Вопрос 12

**Есть ли особенности наследования у классов со статическими членами?** 

**Ответ:** 

Очевидно из предыдущих вопросов! Имеется только одна копия статической переменной — члена класса, и все объекты класса используют ее совместно. Кроме этого, **одна и та же статическая переменная будет использоваться всеми классами, производными от класса, в котором эта статическая переменная содержится.**

***

## Вопрос 13

**Константные и неконстантные параметры метода. Константный метод: назначение, оформление.**

**Ответ:**

Сперва сделаем краткий обзор на константные и неконстантные параметры функции. 

Параметры могут быть константными - значения таких параметров не могут меняться. Константному параметру можно передать в качестве аргумента как константу, так и переменную:
```c++ 
#include <iostream>

void square(const int, const int);

int main()
{
     const int a = 4;
     int b = 5;
     square(a, b);   // 20
     return 0;
}
void square(const int a, const int b)
{
     //a = a * a;     так нельзя сделать
     //b = b * b;     так нельзя сделать
     std::cout << "In square: a * b = " << a * b << std::endl;
}
```        
От этой ситуации следует отличать передачу констант в качестве аргументов для неконстантных параметров:
```c++ 
#include <iostream>

void square(int, int);

int main()
{
     const int a = 4;
     const int b = 5;
     square(a, b);   // 400
     return 0;
}
void square(int a, int b)
{
     a = a * a;
     b = b * b;
     std::cout << "In square: a * b = " << a * b << std::endl;
}
```    
Несмотря на то, что при вызове функции ей передаются константы, но так как сами параметры не являются константными, то функция может изменять их значения. Обзор закончен, переходим к важным вещам!1!!!

Функции — члены класса могут объявляться постоянными (с идентификатором `const`). **Если функция объявлена постоянной, она не может изменить вызывающий ее объект**. Кроме этого, постоянный объект не может вызвать непостоянную функцию-член. Тем не менее, постоянная функция-член может вызываться как постоянными, так и непостоянными объектами.

Обратите внимание, что ключевое слово `const` указывают следом за списком параметров функции, а не перед именем функции:
```c++ 
class X {
     int some_var;
public:
     int fl() const; // постоянная функция-член
};
```
Для примера рассмотрим следующую программу.
```c++ 
#include <iostream>
using namespace std;
class Demo {
          int i;
     public:
          int geti () const {
               return i; // здесь все правильно
          }
          void seti (int x) const {
               i = x; // Ошибка!!!
          }
};
    
int main() {
     Demo ob;
     ob.seti(1900) ;
     cout << ob.geti();
     return 0;
}
```
Данная программа не будет компилироваться, поскольку функция-член `seti()` объявлена постоянной, что означает невозможность изменения вызывающего ее объекта. Таким образом, попытка изменения функцией переменной i ведет к ошибке. С другой стороны, поскольку функция `geti()` не меняет переменной i, она совершенно правильна.

Возможна ситуация, когда вам понадобится, чтобы функция-член, оставаясь постоянной, тем не менее была способна изменить один или несколько членов класса. Это достигается заданием модифицируемых членов класса (ключевое слово `mutable`). **Модифицируемый член класса можно изменить с помощью постоянной функции-члена.**
```c++ 
#include <iostream>
using namespace std;
    
class Demo {
          mutable int i;
          int j ;
     public:
          int geti() const {
               return i; // здесь все правильно
          }
        
          void seti(int x) const {
               i = x; // теперь все правильно
          }
        
          void setj (int x) const {
               j = x; // здесь прежняя ошибка
          }
};
    
int main()
{
     Demo ob;
     ob.seti(1900) ;
     cout << ob.geti () ;
     return 0;
}
```
Здесь переменная i задана модифицируемой, поэтому ее может изменить функция-член `seti()`. Тем не менее, поскольку переменная j по-прежнему остается не модифицируемой, постоянная функция-член `setj()` не может изменить ее значение.

***

## Вопрос 14

**Могут ли одноимённые методы с одинаковыми параметрами различаться лишь константностью по одному из параметров?**

**Ответ:**

Объявления параметров, которые отличаются только наличием или отсутствием `const` и / или `volatile` эквивалентны. Программа не будет компилироваться, поскольку воспринимает их за один и тот же метод.

А вот перегрузить функцию таким образом, чтобы получить константную и неконстантную версии одной и той же функции, возможно. Это работает, потому что квалификатор `const` считается частью сигнатуры функции, поэтому две функции, которые отличаются только своей константностью, считаются разными.

***

## Вопрос 15

**Предопределённый указатель this. Назначение, использование и предосторожности.**

**Ответ:** 

C++ содержит специальный указатель `this`. Это указатель, который **автоматически передается любой функции-члену при ее вызове и указывает на объект, генерирующий вызов**. Явно объявить, инициализировать либо изменить указатель `this`, возможности нет. Поскольку указатель неизменяем, назначения указателю this запрещены.

Важно понимать, что указатель **`this` передается только функциям-членам**. Дружественным функциям указатель `this` не передается.

Указатель объекта `this` не является частью самого объекта. Он не отражается в результате `sizeof` оператора для объекта. Если для объекта вызывается нестатическая функция-член, **компилятор передает адрес объекта функции в качестве скрытого аргумента**. Например, вызов следующей функции
```c++ 
myDate.setMonth(3);
```    
можно интерпретировать следующим образом:
```c++ 
setMonth(&myDate, 3);
```
Использовать указатель `this` можно no-разному. Он **особенно полезен при перегрузке операторов**. 

Выражение `*this` обычно **используется для возврата текущего объекта из функции-члена**:
```c++ 
return *this;
```    
Указатель `this` также **используется для защиты от самосохраняющей ссылки**:
```c++ 
if (&Object != this) {
// do not execute in cases of self-reference
```
A так выглядел бы код, если бы мы всегда прописывали все через указатель `this` (так дейтсвительно можно писать, но это не имеет смысла):
```c++ 
#include <iostream>
#include <cstring>
using namespace std;
        
class inventory {
     char item[20];
     double cost;
     int on_hand;
public:
     inventory (char *i, double c, int o)
     {
          strcpy (this->item, i) ; // доступ к члену
          this->cost = с; // через
          this->on_hand = о; // указатель this
     }
     void show {};
};
        
void inventory::show()
{
     cout << this->item; // использование this для доступа к членам
     cout << ": $" << this->cost;
     cout << " On hand: " << this->on_hand << "\n";
}
```
***

## Вопрос 18

**Дружественные функции: назначение и отличия от методов класса. Понятие дружественного класса.** 

**Ответ:**

Возможны ситуации, когда для получения доступа к закрытым членам класса вам понадобится функция, не являющаяся членом этого класса. Для достижения этой цели в C++ поддерживаются дружественные функции (`friend functions`). **Дружественные функции не являются членами класса, но тем не менее имеют доступ к его закрытым элементам**.

Дружественная функция задается так же, как обычная, не являющаяся членом класса, функция. Однако в объявление класса, для которого функция будет дружественной, необходимо включить ее прототип, перед которым ставится ключевое слово `friend`. В пользу существования дружественных функций имеются несколько доводов, связанных с **перегрузкой операторов и созданием специальных функций ввода/вывода, а так же функций, которые имели бы доступ к закрытым членам двух или более разных классов**.

Чтобы понять, как работает дружественная функция, рассмотрим следующую короткую программу:
```c++ 
#include <iostream>
using namespace std;
    
class myclass {
          int n, d;
     public:
          myclass (int i, int j) { n = i; d = j; }
          // объявление дружественной функции для класса myclass
          friend int isfactor(myclass ob);
};

int isfactor(myclass ob)
{
     if(!(ob.n % ob.d)) return 1;
     else return 0;
}
```    
В этом примере в объявлении класса `myclass` объявляются конструктор и дружественная функция `isfactor()`. Поскольку функция `isfactor()` дружественна для класса `myclass`, то функция `isfactor()` имеет доступ к его закрытой части. Поэтому внутри функции `isfactor()` можно непосредственно ссылаться на объекты ob.n и ob.d.

Важно понимать, что дружественная функция не является членом класса, для которого она дружественна. Поэтому **невозможно вызвать дружественную функцию, используя имя объекта и оператор доступа к члену класса (точку или стрелку)**. Например, по отношению к предыдущему примеру ЭТА ИНСТРУКЦИЯ НЕПРАВИЛЬНА:
```c++ 
obi.isfactor(); // неправильно, isf actor () — это не функция-член
```    
Хотя дружественная функция "знает" о закрытых элементах класса, для которого она является дружественной, доступ к ним она может получить только через объект этого класса. Таким образом, **в отличие от функции-члена `myclass`, в котором можно непосредственно упоминать переменные `n` и `d`, дружественная функция может иметь доступ к этим переменным только через объект, который объявлен внутри функции или передан ей**.

**Класс `friend` — это класс, все функций-члены которого являются дружественными функциями класса**, то есть функции-члены которого имеют доступ к закрытым и защищенным членам другого класса.  Дружественный класс имеет доступ ко всем переменным/функциям исходного класса. Объявляется он так же, как и дружественная функция, с помощью ключевого слова `friend`.

Несколько дополнительных замечаний о дружественных классах. Во-первых, **дружественный класс не имеет прямого доступа к указателю `*this` объектов исходного класса**. Во-вторых, **дружественные отношения не являются взаимными** (сл. вопрос). Если вы хотите, чтобы два класса дружили друг с другом, они оба должны объявить друг друга друзьями. Наконец, если класс A является другом B, а B – другом C, это не означает, что A является другом C.

Будьте осторожны при использовании дружественных функций и классов, потому что это позволяет дружественной функции или классу нарушать инкапсуляцию. Если детали реализации класса изменятся, то детали реализации друга также должны будут быть изменены. Следовательно, ограничьте использование дружественных функций и классов до минимума.

***

## Вопрос 19

**Может ли класс A быть другом класса B, а обратное не справедливо?** 

**Ответ:**

Да. **Дружественные отношения не являются взаимными, если это не указано явным образом.**  

Если A – друг B, то В – не друг А, пока Вы не укажете это явно. Если A – друг B, В – друг С, то А и С не друзья, пока Вы не укажете это явно.

***

## Вопрос 20

**Дружественные базовому классу функции и их использование из порождённых классов.** 

**Ответ:** 

**Дружественные отношения не наследуются**. Поэтому если в базовый класс включается дружественная функция, то эта дружественная функция не является таковой для производных классов. Поскольку дружественная функция принимает ссылку на объект класса или сам объект, чтобы вызвать друга родителя, имея объект класса потомка, **нужно преобразование к типу родителя**.

***

## Вопрос 21

**Может ли одна функция быть дружественной нескольким классам одновременно?**

**Ответ:** 

Функцию **можно объявить дружественно сразу нескольким классам**. Для этого описание класса надо разбить на две части (в момент задания прототипа дружественной 
функции в первом классе должна быть информация существовании второго класса).
```c++ 
class truck; // предварительное объявление
    
class car {
          int passengers;
          int speed;
      public:
          car(int p, int s) { passengers = p; speed = s; }
          friend int sp_greater (car c, truck t) ;
};
    
class truck {
          int weight;
          int speed;
     public:
          truck(int w, int s) { weight = w; speed = s; }
          friend int sp_greater (car c, truck t) ;
};
    
int sp_greater (car c, truck t) { return с. speed — t. speed; }
```    
В этой программе имеется функция `sp_greater()`, которая дружественна для классов `саг` и `truck`. 

Эта программа иллюстрирует один важный элемент синтаксиса C++ — **предварительное объявление** (`forward declaration`), которое еще называют **ссылкой
вперед** (`forward reference`). Поскольку функция `sp_greater()` получает параметры обоих классов `саг` и `truck`, то логически невозможно объявить и тот и другой
класс перед включением функции `sp_greater()` в каждый из них. Поэтому необходим иной способ сообщить компилятору имя класса без его фактического объявления. Этот способ и называется предварительным объявлением. В C++, чтобы информировать компилятор о том, что данный идентификатор является именем класса, перед первым использованием имени класса вставляют следующую строку:
```c++ 
class имя_класса; 
```
***

## Вопрос 22

**Может ли метод одного класса быть другом другого класса?**

**Ответ:**

**Да**. Сделаем метод класса А дружественной функцией для В. О классе B должно быть известно перед заданием класса А.
```c++ 
class B;
   
class A {
     private:
          int x;
     public:
          A() { x = 1; }
          void print() { cout << x; }
          void f(B b);
};
    
class B {  
     private:
          int y;
     public:
          B() { y = 5; }
          friend void A::f(B b);
};
    
void A::f(B b) { x = b.y; }
```
***

## Вопрос 23

**Перегрузка функций: назначение и правила. Проиллюстрируйте простыми примерами допустимых и недопустимых вариантов перегрузки.**

**Ответ:** 

**Перегрузка функций** – это возможность использовать одно имя функции для множества различных действий. Это означает, что **можно создать общий интерфейс для группы близких по смыслу действий**. Т.е. перегруженные функции позволяют упростить программы, допуская обращение к одному имени для выполнения близких по смыслу действий. В C++ две или более функции могут **иметь одно и то же имя, отличаясь либо типом, либо числом своих аргументов, либо и тем и другим**.

Перегрузить функцию очень легко: просто объявите и определите все требуемые варианты. Компилятор автоматически выберет правильный вариант вызова на основании числа и/или типа используемых в функции аргументов.

**ПРИМЕРЫ**

1. Для языка С, в котором полиморфизм поддерживается недостаточно, нахождение абсолютной величины числа требует трех различных функций: `abs()`, `labs()` и `fabs()`. Эти функции подсчитывают и возвращают абсолютную величину целых, длинных целых и чисел с плавающей точкой соответственно. В C++ каждая из этих функций может быть названа `abs()`. Так выглядит реализация этого:
```c++ 
#include <iostream>
using namespace std;

// Перегрузка abs() тремя способами
int abs(int n);
long abs(long n);
double abs(double n);

int main() {
     cout << "Абсолютная величина -10:" << abs(-10) << "\n/n";
     cout << "Абсолютная величина -10L:" << abs (-10L) << "\n/n";
     cout << "Абсолютная величина -10.01:" << abs (-10. 01) << "\n/n";
     return 0;
}

// abs() для целых
int abs (int n) {
     cout << "В целом abs()\n";
     return n < 0 ? -n: n;
}

// abs() для длинных целых
long abs (long n) {
     cout << "В длинном целом abs()\n";
     return n < 0 ? -n: n;
}

// abs() для вещественных двойной точности
double abs (double n} {
     cout << "В вещественном abs() двойной точности \n";
     return n < 0 ? -n: n;
}
```
2. Здесь могли быть кодики с перегрузкой функций, отличающихся типами и/или числом принимаемых параметров, но их не будет, потому что вы умняшки и сами все умеете 

3. ПРИМЕР НЕДОПУСТИМОЙ ПЕРЕГРУЗКИ ФУНКЦИИ. Важно понимать, что **тип возвращаемого значения сам по себе еще не является достаточным отличием для перегрузки функции**. Если две функции отличаются только типом возвращаемых данных, компилятор не всегда сможет выбрать нужную.
                
```c++ 
// Это все неправильно и не будет компилироваться
int fl{int a);
double fl{int а);
...         
f1 (10); // какую функцию выбрать компилятору???         
```
***

## Вопрос 26

**Может ли одна и та же операция в одном и том же классе быть перегруженной разными способами?** 

**Ответ:** 

Один и тот же оператор **можно перегрузить несколько раз**. Для унарных операторов может быть всего два варианта — с квалификатором `const` и без него (для функций-членов), или варианты с параметром типа константная ссылка или обычная ссылка (для свободных функций). Для бинарных операторов и оператора () количество перегрузок не ограничено.

***

## Вопрос 36

**Перегрузка new и delete. Различие скалярной и векторной форм.**

**Ответ:**

Оператор `new` нужно перегружать в случаях, если **память выделяется по-особому (нестандартным способом)**. Соответственно, оператор `delete` должен освобождать эту память нестандартным способом. Как правило, **если в классе перегружается оператор `new`, то в этом классе также перегружается оператор `delete`**.

Операторы `new` и `delete` **могут быть перегружены двумя способами**. Эти способы отличаются объявлением операторной функции:

•	перегрузка операторов `new` и `delete` с помощью операторной функции, которая реализована в пределах класса. Это есть способ перегрузки `new` и `delete` для конкретного класса. При вызове `new` и `delete` для этого класса будут вызваны перегруженные операторные функции, которые выделяют/освобождают память специфическим образом. При вызове операторов `new` и `delete` для других классов используются глобальные операторы `new` и `delete`;

•	глобальная перегрузка операторов `new` и `delete`. В этом случае операторы `new` и `delete` перегружаются для встроенных типов (`float`, `int` и т.д.).

**Общая форма перегрузки оператора `new` имеет следующий вид:** 
```c++
return_type* operator new (size_t size) { }
```
в которой

•	`return_type` – тип (класс), на который операторная функция возвращает указатель, для которого выделена память по особому (нестандартным способом). Зачастую здесь используют **указатель на пустоту `void*`**, везде разная инфа;

•	`size` – размер памяти, которая выделяется для типа `return_type`. Количество байт выделяемой памяти не обязательно должно совпадать со значением `size`, так как в теле операторной функции память можно выделять по-особому.

**Общая форма перегрузки оператора `delete` имеет следующий вид:**
```c++
void operator delete (void* pointer) { }
```
в которой `pointer` – указатель на область памяти, которая была предварительно выделена оператором `new`.

Внутри метода `operator new()` для выделения памяти обычно используется функция `malloc()`, а для освобождения памяти внутри метода `operator delete()` — функция `free()`. Либо же с помощью оператора `::` можно получить доступ к соответствующим стандартным функциям.

**ПРИМЕРЫ**
1. С помощью оператора `::` внутри класса:
```c++
class X
{
// ...
public:
    void* operator new(std::size_t size)
    {
        std::cout << "X new\n";
        return ::operator new(size);
    }

    void operator delete(void* ptr)
    {
        std::cout << "X delete\n";
        ::operator delete(ptr);
    }

    void* operator new[](std::size_t size)
    {
        std::cout << "X new[]\n";
        return ::operator new[](size);
    }

    void operator delete[](void* ptr)
    {
        std::cout << "X delete[]\n";
        ::operator delete[](ptr);
    }
};
```
2. С помощью функций `malloc()` и `free()` в виде внешней функции:
```c++
class C {
   ...
   void* operator new(size_t count);
   void operator delete(void *p);
};

void* C::operator new(size_t count) {
   std::cout << "new count=" << count << std::endl;
   void* p = std::malloc(count);   // Выделяем память
   if (!p) throw std::bad_alloc(); // Проверка и генерация исключения
   return p;                       // Возвращаем указатель
}

void C::operator delete(void* p) {
   std::cout << "delete" << std::endl;
   std::free(p);                   // Освобождаем память
}
```

Для **выделения динамических массивов С++ предоставляет векторную форму** операторов `new` и `delete`: `new[]` и `delete[]`. Пример перегрузки векторных форм этих операторов так же приведен выше. 

Когда оператор `new[]` используется для создания массива объектов, то сначала выделяется память для всего массива. Если выделение прошло успешно, то вызывается конструктор по умолчанию (или другой конструктор, если есть инициализатор) для каждого элемента массива начиная с нулевого. Если какой-нибудь конструктор выбрасывает исключение, то для всех созданных элементов массива вызывается деструктор в порядке, обратном вызову конструктора, затем выделенная память освобождается. Для удаления массива надо вызвать оператор `delete[]`, при этом для всех элементов массива вызывается деструктор в порядке, обратном вызову конструктора, затем выделенная память освобождается.

**Внимание!** Необходимо вызывать правильную форму оператора `delete` в зависимости от того, удаляется одиночный объект или массив. Это правило надо соблюдать неукоснительно, иначе можно получить неопределенное поведение, то есть может случиться все, что угодно: утечки памяти, аварийное завершение и т.д. 

***

## Вопрос 45

**Можно ли перегружать конструктор? Почему?** 

**Ответ:**

В программах на C++ **перегрузка конструктора класса вполне обычна**. Имеется три основных причины перегрузки конструктора, которая, как правило, 
выполняется либо для обеспечения гибкости, либо для поддержки массивов, либо для создания конструкторов копий.

Необходимо запомнить одну вещь: **каждому способу объявления объекта класса должна соответствовать своя версия конструктора класса.** Если 
эта задача не решена, то при компиляции программы обнаружится ошибка. Именно поэтому перегрузка конструктора столь обычна для программ C++.

Изучить на более подробных примерах перегрузку конструкторов можно на [стр. 144](https://disk.yandex.ru/i/KoKMQ5xd3NhoMR) (или в вопросе 47)

***

## Вопрос 46

**Можно ли перегружать деструктор? Почему?** 

**Ответ:** 

Перегрузка означает наличие нескольких функций с одинаковым именем, которые принимают разные аргументы. **Деструктор не принимает аргументов, и поэтому перегрузка 
не имеет смысла.** Кроме того, деструктор вызывается автоматически и при его перегрузке программа не будет понимать, какой именно деструктор следует использовать.

Если вам нужно делать разные вещи при уничтожении объекта в зависимости от определенных обстоятельств, вам просто нужны соответствующие операторы 
`if` в вашем деструкторе для проверки этих обстоятельств.

***

## Вопрос 47

**Передача параметров в конструктор и перегрузка конструктора. Что можно сказать о перегрузке деструктора? Конструктор по умолчанию.** 

**Ответ:** 

Для каждого создаваемого вами объекта требуется какого-то вида инициализация. Для разрешения этой проблемы в C++ имеется **функция-конструктор** (constructor function), включаемая в описание класса. Конструктор класса вызывается всякий раз при создании объекта этого класса. Таким образом, любая необходимая объекту инициализация при наличии конструктора выполняется автоматически. Конструктор имеет то же имя, что и класс, частью которого он является, и не имеет возвращаемого значения. Для глобальных объектов конструктор объекта вызывается тогда, когда начинается выполнение программы. Для локальных объектов конструктор вызывается всякий раз при выполнении инструкции объявления переменной.

Конструктор, не требующий параметров, называется **конструктором по умолчанию**. Это может быть конструктор с пустым списком параметров или конструктор, в котором все аргументы имеют значения по умолчанию. Конструкторы могут быть перегруженными, но конструктор по умолчанию может быть только один.

В C ++ конструкторы по умолчанию имеют существенное значение, поскольку они автоматически вызываются при определенных обстоятельствах, и, следовательно, при определённых условиях класс обязан иметь конструктор по умолчанию, иначе возникнет ошибка:
1. Когда объект объявляется без аргументов (например, `MyClass x;`) или создаётся новый экземпляр в памяти (например, `new MyClass;` или `new MyClass();`).
2. Когда объявлен массив объектов, например, `MyClass x[10];`; или объявлен динамически, например `new MyClass [10]`. Конструктор по умолчанию инициализирует все элементы.
3. Когда в классе потомке не указан явно конструктор класса родителя в списке инициализации.
4. Когда конструктор класса не вызывает явно конструктор хотя бы одного из своих полей-объектов в списке инициализации.
5. В стандартной библиотеке определённые контейнеры заполняют свои значения используя конструкторы по умолчанию, если значение не указано явно. Например, `vector<MyClass>(10);` заполняет вектор десятью элементами, инициализированными конструктором по умолчанию.

Если определены конструкторы для класса, но среди них нет конструктора по умолчанию, компилятор не создаст неявно таковой.

Конструкторы по умолчанию являются одной из специальных функций-членов. Если конструкторы в классе не объявляются, компилятор предоставляет неявный `inline` конструктор по умолчанию. Вы можете запретить компилятору создавать неявный конструктор по умолчанию, определив его как удаленный:
```c++
// Default constructor
    Box() = delete;
```
Или же явно указать его:
```c++
// Default constructor
    Box() = default;
```
**Конструктору можно передавать аргументы**. Для этого необходимо просто добавить необходимые параметры в объявление и определение конструктора. Затем при
объявлении объекта задать параметры в качестве аргументов. Мы все это делали, все просто. В отличие от конструктора **деструктор не может иметь параметров**. Смысл
этого понять достаточно просто: **отсутствует механизм передачи аргументов удаленному объекту**. Подробнее про перегрузку деструктора в вопросе 46.

В программах на C++ перегрузка конструктора класса вполне обычна. Деструктор, однако, перегружать нельзя. **Имеется три основных причины перегрузки конструктора**:
1. для обеспечения гибкости; 
2. для поддержки массивов;
3. для создания конструкторов копий. 
    
**ПРИМЕР**

Одна из ситуаций, в которой вам потребуется перегрузить конструктор класса, возникает при выделении динамической памяти массиву объектов этого
класса. Известно, что динамический массив не может быть инициализирован. Поэтому, если в классе есть инициализирующий конструктор, вам необходимо включить туда и его перегруженную версию без инициализации. Например, ниже приведена программа, в которой массиву объектов динамически выделяется память.
```c++
#include <iostream>
using namespace std;

class myclass {
     int x;
public:
     // перегрузка конструктора двумя способами
     myclass () { x = 0; } // нет инициализации
     myclass (int n) { x = n; } // инициализация
     int getx() ( return x; }
     void setx(int n) { x = n; }
};

int main() {
     myclass *p;
     myclass ob(10); // инициализация отдельной переменной
     p = new myclass[10]; // здесь инициализировать нельзя
     if (!p) {
          cout << "Ошибка выделения памяти\п";
          return 1;
     }
     int i;
     // инициализация всех элементов значением ob
     for(i = 0; i < 10; i++) p[i] = ob;
     for(i = 0; i < 10; i++) {
          cout << "p[ " << i << "]:" << p[i].getx
          cout << '\n' ;
     }
     return 0;
}
```
Без перегруженной версии конструктора `myclass()`, в которой отсутствует инициализация, оператор `new` при компиляции вызвал бы ошибку.

И совсем немного про конструктор копий (кажется, про него есть отдельный вопрос).

Одной из важнейших форм перегруженного конструктора является **конструктор копий** (copy constructor). Для начала давайте обозначим проблемы, для решения которых предназначен конструктор копий. Когда объект передается в функцию, делается поразрядная (т. е. точная) копия этого объекта и передается тому параметру
функции, который получает объект. Однако бывают ситуации, в которых акая точная копия объекта нежелательна. Например, если объект содержит
указатель на выделенную область памяти, то в копии указатель будет ссылаться на ту же самую область памяти, на которую ссылается исходный
указатель. Следовательно, если копия меняет содержимое области памяти, то эти изменения коснутся также и исходного объекта! Кроме того, когда
выполнение функции завершается, копия удаляется, что приводит к вызову деструктора этой копии. Вызов деструктора может привести к нежелательным побочным эффектам, которые в дальнейшем повлияют на исходный объект. Эта ситуация возникала в 6-ой практической, поэтому прелагаю разобрать ее более детально на примере линкед листа.

При копировании контейнера, такого как связанный список, вероятно, потребуется **глубокая копия**, поэтому необходимо создать новые узлы и скопировать только данные. Указатели и в узлах нового списка должны ссылаться на новые узлы, созданные специально для этого списка, а не на узлы из исходного списка. Эти новые узлы будут иметь копии соответствующих данных из исходного списка, так что новый список можно считать по значению или глубокой копией. Вот картинка, изображающая различия между неглубоким и глубоким копированием:

![image](https://user-images.githubusercontent.com/90936335/173569287-8770434b-7c8e-4683-9703-6965fe2a18f2.png)

Обратите внимание, что в части схемы Deep Copy ни один из узлов не указывает на узлы в старом списке. Для получения дополнительной информации о разнице между неглубокими и глубокими копиями см. [статью Википедии](https://en.wikipedia.org/wiki/Object_copying) о копировании объектов. 

Важно понимать, что в C++ точно разделяются два типа ситуаций, в которых значение одного объекта передается другому. Первая ситуация — это присваивание. Вторая — инициализация, которая может иметь место в трех случаях:

1. Когда в инструкции объявления объекта один объект используется для инициализации другого.
2. Когда объект передается в функцию в качестве параметра
3. Когда в качестве возвращаемого значения функции создается временный объект.

**Конструктор копий употребляется только для инициализации, но не для присваивания.**
