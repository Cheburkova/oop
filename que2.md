# Вопросы 1, 10-15, 18-23, 26, 36, 45-47

## Вопрос 1
#### Чем отличается класс от структуры в смысле Си? Как выбрать между классом и структурой в C++? 
#### Ответ: 

Класс — это механизм для создания объектов. Классы представляют собой новые типы данных, которые вводятся в код программистом. 
Обычно пользоваться стандартными типами данных (int, double и т.п.) для описания какого-либо явления или объекта не удобно, т.к. сложный объект 
характеризуется множеством полей (хранимых данных). Для этого вводятся новые типы, которые зачастую обладают большим количеством полей
(хранимых внутри себя переменных). В этом смысле класс лежит в основе многих свойств C++. 

Класс объявляется с помощью ключевого слова `class`. Синтаксис объявления класса похож на синтаксис объявления структуры. Здесь показана основная форма:

    class имя_класса. {  
    // закрытие функции и переменные класса.   
    public:  
    // открытые функции и переменные класса.  
    } список_объектов;

В объявлении класса список_объектов не обязателен. Как и в случае со структурой, вы можете объявлять объекты класса позже, по мере необходимости.

Вас, возможно, удивило то, что класс и структура имеют фактически одинаковые свойства. В C++ определение структуры расширили таким образом, что туда, 
как и в определение класса, удалось включить функции-члены, в том числе конструкторы и деструкторы. Единственным отличием между структурой 
и классом является то, что **члены класса, по умолчанию, являются закрытыми (private), а члены структуры — открытыми (public).**
Однако **в рамках языка Си структура могла содержать только данные, функции обработки структуры были отделены от объектов структуры.**

Структура объявляется с помощью ключевого слова `struct`. Здесь показан расширенный синтаксис описания структуры:

    struct имя_типа. {  
    // открытые функции и данные — члены класса.  
    private:  
    // закрытие функция и данные — члены класса.   
    } список_объектов;

Таким образом, в соответствии с формальным синтаксисом C++ как структура, так и класс создают новые типы данных. 

Хотя структуры имеют схожие с классами возможности, **большинство программистов ограничивают использование структур взятыми из С формами и
не применяют их для задания функций-членов.** Для задания объекта, содержащего данные и код, эти программисты обычно указывают ключевое слово
class. Однако все это относится к стилистике и является предметом вашего собственного выбора. 

**`Замечание` (для тех, кому все-таки интерсно, зачем нужны структуры в рамках C++).** Объяснение этому может быть дано в "строгой" и "мягкой" формах.

"Строгий" довод состоит в том, что необходимо поддерживать линию на совместимость с С. Стиль задания структур С совершенно допустим и для
программ C++. Поскольку в С все члены структур по умолчанию открыты, это положение также поддерживается и в C++. Кроме этого, поскольку
класс синтаксически отличается от структуры, определение класса открыто для развития в направлении, которое в конечном итоге может привести к
несовместимости со взятым из С определением структуры. Если эти два пути разойдутся, то направление, связанное с C++, уже не будет избыточным.

"Мягким" доводом в пользу наличия двух сходных конструкций стало отсутствие какого-либо ущерба от расширения определения структуры в C++
таким образом, что в нее стало возможным включение функций-членов.

***

## Вопрос 10
#### Статические и нестатические атрибуты и методы класса: различия и возможности.
#### Ответ: 


***

## Вопрос 11
#### Чем отличается статический метод от статического атрибута класса? 
#### Ответ: 


***

## Вопрос 12
#### Есть ли особенности наследования у классов со статическими членами? 
#### Ответ: 


***

## Вопрос 13
#### Константные и неконстантные параметры метода. Константный метод: назначение, оформление. 
#### Ответ: 


***

## Вопрос 14
#### Могут ли одноимённые методы с одинаковыми параметрами различаться лишь константностью по одному из параметров? 
#### Ответ: 


***

## Вопрос 15
#### Предопределённый указатель this. Назначение, использование и предосторожности.
#### Ответ: 


***

## Вопрос 18
#### Дружественные функции: назначение и отличия от методов класса. Понятие дружественного класса. 
#### Ответ: 


***

## Вопрос 19
#### Может ли класс A быть другом класса B, а обратное не справедливо? 
#### Ответ: 

Да. **Дружественные отношения не являются взаимными, если это не указано явным образом.**  

Если A – друг B, то В – не друг А, пока Вы не укажете это явно. Если A – друг B, В – друг С, то А и С не друзья, пока Вы не укажете это явно.

***

## Вопрос 20
#### Дружественные базовому классу функции и их использование из порождённых классов. 
#### Ответ: 


***

## Вопрос 21
#### Может ли одна функция быть дружественной нескольким классам одновременно? 
#### Ответ: 


***

## Вопрос 22
#### Может ли метод одного класса быть другом другого класса?
#### Ответ: 

***

## Вопрос 23
#### Перегрузка функций: назначение и правила. Проиллюстрируйте простыми примерами допустимых и недопустимых вариантов перегрузки.
#### Ответ: 

***

## Вопрос 26
#### Может ли одна и та же операция в одном и том же классе быть перегруженной разными способами? 
#### Ответ: 


***

## Вопрос 45
#### Можно ли перегружать конструктор? Почему? 
#### Ответ: 

В программах на C++ **перегрузка конструктора класса вполне обычна**. Имеется три основных причины перегрузки конструктора, которая, как правило, 
выполняется либо для обеспечения гибкости, либо для поддержки массивов, либо для создания конструкторов копий.

Необходимо запомнить одну вещь: **каждому способу объявления объекта класса должна соответствовать своя версия конструктора класса.** Если 
эта задача не решена, то при компиляции программы обнаружится ошибка. Именно поэтому перегрузка конструктора столь обычна для программ C++.

Изучить на более подробных примерах перегрузку конструкторов можно на стр. 144 - <https://disk.yandex.ru/i/KoKMQ5xd3NhoMR> (можно я не буду переносить их сюда, спасибо)

***

## Вопрос 46
#### Можно ли перегружать деструктор? Почему? 
#### Ответ: 

Перегрузка означает наличие нескольких функций с одинаковым именем, которые принимают разные аргументы. **Деструктор не принимает аргументов, и поэтому перегрузка 
не имеет смысла.** Кроме того, деструктор вызывается автоматически и при его перегрузке программа не будет понимать, какой именно деструктор следует использовать.

Если вам нужно делать разные вещи при уничтожении объекта в зависимости от определенных обстоятельств, вам просто нужны соответствующие операторы 
`if` в вашем деструкторе для проверки этих обстоятельств.

***

## Вопрос 47
#### Передача параметров в конструктор и перегрузка конструктора. Что можно сказать о перегрузке деструктора? Конструктор по умолчанию. 
#### Ответ: 

